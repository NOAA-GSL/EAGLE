name: Nested Eagle CI Pipeline

# Controls when the action will run. Workflow runs when manually triggered using the UI
# or API.
on:
  pull_request_review:
    types: [submitted]
    paths:
      - "nested_eagle/**" #only run for changes to nested eagle changes.
jobs:
  Submit_Grids:
    if: ${{ github.event.review.state == 'approved' && !contains(github.event.pull_request.labels.*.name, 'ci-running') }}
    # Only run the workflow if a PR is submitted and approved.
    runs-on: ursa
    timeout-minutes: 1440

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      - name: Checkout pull request branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          repository: ${{ github.event.pull_request.head.repo.full_name }}
      - name: Add a ci-running label
        uses: actions-ecosystem/action-add-labels@v1
        with:
          labels: "ci-running" # Adding ci-running label to prevent duplicate runs.
          github_token: ${{ secrets.GITHUB_TOKEN }}
      - name: Submit Initial Grids
        run: |
          set -euo pipefail
          cd "${GITHUB_WORKSPACE}/nested_eagle/ursa/scientific_workflow/data" 

          submit_and_wait() {
            local submit_script="$1"
            JOB_ID=$(sbatch "$submit_script" | awk '{print $4}')
            echo "Submitted Slurm job with ID: $JOB_ID"
            while true; do
              STATE=$(sacct -j "$JOB_ID" --format=State --noheader | head -n1 | awk '{print $1}')
              case "${STATE:-}" in
                COMPLETED) echo "Slurm job $JOB_ID COMPLETED"; break ;;
                FAILED|CANCELLED|TIMEOUT|NODE_FAIL|OUT_OF_MEMORY)
                  echo "Slurm job $JOB_ID terminal failure: $STATE"; exit 1 ;;
                ""|PENDING|RUNNING|CONFIGURING|COMPLETING|SUSPENDED|REQUEUED|RESIZING|STAGE_OUT|STOPPED) ;;
                *) echo "Slurm job $JOB_ID state: $STATE" ;;
              esac
              sleep 20
            done
          }

          submit_and_wait submit_grids.sh
          echo "Grid generation completed."

  Prepare_Training_Data:
    # The type of runner that the job will run on
    runs-on: ursa
    timeout-minutes: 1440
    needs: Submit_Grids
    steps:
      - name: Prepare GFS & HRRR Training Data
        run: |
          set -euo pipefail 
          cd "${GITHUB_WORKSPACE}/nested_eagle/ursa/scientific_workflow/data" 

          submit_job() {
            local script="$1"
            sbatch "$script" | awk '{print $4}'
          }

          wait_terminal() {
            local id="$1"
            while true; do
              STATE=$(sacct -j "$id" --format=State --noheader | head -n1 | awk '{print $1}')
              case "${STATE:-}" in
                COMPLETED) echo "Job $id COMPLETED"; break ;;
                FAILED|CANCELLED|TIMEOUT|NODE_FAIL|OUT_OF_MEMORY)
                  echo "Job $id terminal failure: $STATE"; exit 1 ;;
                ""|PENDING|RUNNING|CONFIGURING|COMPLETING|SUSPENDED|REQUEUED|RESIZING|STAGE_OUT|STOPPED) ;;
                *) echo "Job $id state: $STATE" ;;
              esac
              sleep 20
            done
          }

          JOB_ID1=$(submit_job submit_gfs.sh)
          JOB_ID2=$(submit_job submit_hrrr.sh)
          echo "Submitted GFS: $JOB_ID1"
          echo "Submitted HRRR: $JOB_ID2"

          wait_terminal "$JOB_ID1"
          wait_terminal "$JOB_ID2"

          echo "GFS & HRRR training data preparation completed."

  Run_Training:
    # The type of runner that the job will run on
    runs-on: ursa
    timeout-minutes: 1440
    needs: Prepare_Training_Data
    steps:
      - name: Run Training With GFS & HRRR Input
        run: |
          set -euo pipefail
          cd nested_eagle/ursa/scientific_workflow/training

          CHECKPOINT_DIR="$PWD/outputs/checkpoint"

          JOB_ID=$(sbatch submit_training.sh | awk '{print $4}')
          echo "Submitted Training Slurm job with ID: $JOB_ID"

          # Wait for either a checkpoint to appear, or terminal state
          while true; do
            if [ -d "$CHECKPOINT_DIR" ] && [ -n "$(ls -A "$CHECKPOINT_DIR" 2>/dev/null || true)" ]; then
              echo "Checkpoint detected at $CHECKPOINT_DIR â€” stopping training."
              scancel "$JOB_ID" || true
              sleep 10
              break
            fi

            STATE=$(sacct -j "$JOB_ID" --format=State --noheader | head -n1 | awk '{print $1}')
            case "${STATE:-}" in
              COMPLETED) echo "Training job $JOB_ID COMPLETED before checkpoint detection."; break ;;
              FAILED|CANCELLED|TIMEOUT|NODE_FAIL|OUT_OF_MEMORY)
                echo "Training job $JOB_ID terminal failure: $STATE"; exit 1 ;;
              ""|PENDING|RUNNING|CONFIGURING|COMPLETING|SUSPENDED|REQUEUED|RESIZING|STAGE_OUT|STOPPED) ;;
              *) echo "Training job $JOB_ID state: $STATE" ;;
            esac
            sleep 20
          done

          # Optional: ensure the most recent checkpoint file is fully written (if present)
          if compgen -G "$CHECKPOINT_DIR/*.ckpt" > /dev/null; then
            CKPT_FILE=$(ls -1t "$CHECKPOINT_DIR"/*.ckpt | head -n1)
            echo "Latest checkpoint: $CKPT_FILE"
            # If lsof exists and file is open, wait a bit; otherwise continue
            if command -v lsof >/dev/null 2>&1; then
              if lsof -w "$CKPT_FILE" >/dev/null 2>&1; then
                echo "Checkpoint file still open; waiting 10s..."
                sleep 10
              fi
            fi
          fi

          echo "Training stage completed (checkpoint available)."


  Run_Inference:
    # The type of runner that the job will run on
    runs-on: ursa
    timeout-minutes: 1440
    needs: Run_Training
    steps:
      - name: Run Inference against the training data
        run: |
          set -euo pipefail
          cd "${GITHUB_WORKSPACE}/nested_eagle/ursa/scientific_workflow/inference" 

          submit_and_wait() {
            local submit_script="$1"
            JOB_ID=$(sbatch "$submit_script" | awk '{print $4}')
            echo "Submitted Slurm job with ID: $JOB_ID"
            while true; do
              STATE=$(sacct -j "$JOB_ID" --format=State --noheader | head -n1 | awk '{print $1}')
              case "${STATE:-}" in
                COMPLETED) echo "Slurm job $JOB_ID COMPLETED"; break ;;
                FAILED|CANCELLED|TIMEOUT|NODE_FAIL|OUT_OF_MEMORY)
                  echo "Slurm job $JOB_ID terminal failure: $STATE"; exit 1 ;;
                ""|PENDING|RUNNING|CONFIGURING|COMPLETING|SUSPENDED|REQUEUED|RESIZING|STAGE_OUT|STOPPED) ;;
                *) echo "Slurm job $JOB_ID state: $STATE" ;;
              esac
              sleep 20
            done
          }

          submit_and_wait submit_inference.sh

          cd "${GITHUB_WORKSPACE}/nested_eagle/ursa/scientific_workflow/inference"
          find ./inference_files -name "*.nc" -print -quit | grep -q . || { echo "Error: No inference files found."; exit 1; }
          echo "Inference stage completed."

  Perform_Inference_Postprocessing:
    runs-on: ursa
    timeout-minutes: 1440
    needs: Run_Inference
    steps:
      - name: Perform inference postprocessing
        run: |
          set -euo pipefail
          cd "${GITHUB_WORKSPACE}/nested_eagle/ursa/scientific_workflow/verification/prewxvx" 

          mkdir -p postprocessed_files/lam
          mkdir -p postprocessed_files/global

          submit_and_wait() {
            local submit_script="$1"
            JOB_ID=$(sbatch "$submit_script" | awk '{print $4}')
            echo "Submitted Slurm job with ID: $JOB_ID"
            while true; do
              STATE=$(sacct -j "$JOB_ID" --format=State --noheader | head -n1 | awk '{print $1}')
              case "${STATE:-}" in
                COMPLETED) echo "Slurm job $JOB_ID COMPLETED"; break ;;
                FAILED|CANCELLED|TIMEOUT|NODE_FAIL|OUT_OF_MEMORY)
                  echo "Slurm job $JOB_ID terminal failure: $STATE"; exit 1 ;;
                ""|PENDING|RUNNING|CONFIGURING|COMPLETING|SUSPENDED|REQUEUED|RESIZING|STAGE_OUT|STOPPED) ;;
                *) echo "Slurm job $JOB_ID state: $STATE" ;;
              esac
              sleep 20
            done
          }

          submit_and_wait submit_postprocessing.sh

          cd "${GITHUB_WORKSPACE}/nested_eagle/ursa/scientific_workflow/verification/prewxvx/postprocessed_files"
          find ./global -name "*.nc" -print -quit | grep -q . || { echo "Error: No global postprocessed files found."; exit 1; }
          find ./lam -name "*.nc" -print -quit | grep -q . || { echo "Error: No lam postprocessed files found."; exit 1; }
          echo "Inference postprocessing completed."

  Perform_Verification:
    # The type of runner that the job will run on
    runs-on: ursa
    timeout-minutes: 1440
    needs: Perform_Inference_Postprocessing
    steps:
      - name: Perform grid2obs and grid2obs verification with wxvx
        run: |
          set -euo pipefail

          cd "${GITHUB_WORKSPACE}/nested_eagle/ursa/scientific_workflow/verification/grid2obs"
          JOB_ID1=$(sbatch submit_obs_verification.sh | awk '{print $4}')

          cd "${GITHUB_WORKSPACE}/nested_eagle/ursa/scientific_workflow/verification/grid2grid"
          JOB_ID2=$(sbatch submit_grid_verification.sh | awk '{print $4}')

          echo "Submitted grid2obs: $JOB_ID1"
          echo "Submitted grid2grid: $JOB_ID2"

          wait_terminal() {
            local id="$1"
            while true; do
              STATE=$(sacct -j "$id" --format=State --noheader | head -n1 | awk '{print $1}')
              case "${STATE:-}" in
                COMPLETED) echo "Job $id COMPLETED"; break ;;
                FAILED|CANCELLED|TIMEOUT|NODE_FAIL|OUT_OF_MEMORY)
                  echo "Job $id terminal failure: $STATE"; exit 1 ;;
                ""|PENDING|RUNNING|CONFIGURING|COMPLETING|SUSPENDED|REQUEUED|RESIZING|STAGE_OUT|STOPPED) ;;
                *) echo "Job $id state: $STATE" ;;
              esac
              sleep 20
            done
          }

          wait_terminal "$JOB_ID1"
          wait_terminal "$JOB_ID2"

          cd "${GITHUB_WORKSPACE}/nested_eagle/ursa/scientific_workflow/verification/grid2obs/wxvx_workdir"
          find ./lam -name "*.png" -print -quit | grep -q . || { echo "Error: No LAM grid2obs verification plots found."; exit 1; }
          find ./global -name "*.png" -print -quit | grep -q . || { echo "Error: No global grid2obs verification plots found."; exit 1; }
          echo "Grid2obs verification completed."

          cd "${GITHUB_WORKSPACE}/nested_eagle/ursa/scientific_workflow/verification/grid2grid/wxvx_workdir"
          find ./lam -name "*.png" -print -quit | grep -q . || { echo "Error: No LAM grid2grid verification plots found."; exit 1; }
          find ./global -name "*.png" -print -quit | grep -q . || { echo "Error: No global grid2grid verification plots found."; exit 1; }
          echo "Grid2grid verification completed."


      - name: Remove label from pull request
        if: always()
        uses: mondeja/remove-labels-gh-action@v2.0.0
        with:
          labels: "ci-running"
          token: ${{ secrets.GITHUB_TOKEN }}
